package google.google2020.google_加油少年_OnS;

/*

狗家近期的大杀器人车匹配出现率很高，同时挂人率也很高，而且一直没见到非常清楚的分析，自己想了想感觉挺有意思，开个帖子希望大家讨论一下。

原题：一组坐标表示人，另一组表示车，车比人多，给每个人匹配最近的车。其中人和车的距离没有tie。

原题还比较简单，最笨的bfs也可以做，坐标数值很大的时候，时间复杂度可能会很高，稍微好一点的是用pq存所有的人车距离，每次poll最小的距离，
如果这个人已经匹配到车了继续poll，直到所有人都匹配到车为止。


本题的杀招主要在follow up，我知道的描述清晰准确的有以下版本，有见过其他版本的欢迎补充！！
follow up版本1: 一组坐标表示人，另一组表示车，车比人多，其中人和车的距离有tie（距离两个人最近的车可能是同一辆），
给每个人匹配一辆车，要求所有匹配的人车曼哈顿距离加起来最小（全局最优）。
这一问原题的两种方法基本全部gg，因为要求全局最优并且有tie，于是每个人不一定是匹配到距离自己最近的车子。
pq方法完全失效，bfs方法无法保证全局最优（距离一个人最近的车可能有多辆，然而单凭bfs无法确定给此人匹配哪辆可以全剧最优）。
暴力搜索全部匹配方式，找最小总距离的匹配方式可以确保正确性，但是车和人很多的时候，时间复杂度会很高。
目前个人认为这一题面试官的期待做法，应该就是二分图最小带权匹配，KM算法，但是鉴于面试的时候可能很难写出，
所以在此希望大家讨论一下有没有其他稍微简单点的办法，因为和正常的二分图匹配不一样，这个已经告诉你那些节点属于哪一边了。


follow up版本2: 一组坐标表示人，另一组表示车，车比人多，其中人和车的距离有tie（距离两个人最近的车可能是同一辆），
给每个人匹配一辆车，要求匹配后最大的人车距离最小。
这一问和前面的关系似乎不是很大，不过万能的暴力dfs还是能做，全部匹配方法写出来，找最长距离最小的那个，就是答案，
不过和前面一样，没有非常有效的剪枝方法，复杂度很高，所以面试官也不会满意（我同学面试答了这种方法挂掉了）。
感觉可以用dp来做，但是没有想出很好的状态表示和转移方程，希望大家讨论！！！！
 */

public class BicycleMatch {
}
